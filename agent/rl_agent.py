from . import BaseAgent
from common.registry import Registry
from gym import spaces
from generator import LaneVehicleGenerator, IntersectionPhaseGenerator, IntersectionVehicleGenerator
import random
import numpy as np


@Registry.register_model('rl')
class RLAgent(BaseAgent):
    '''
    RLAgent Class is mainly used for creating a rl-based agent and base methods.
    '''
    def __init__(self, world, rank):
        super().__init__(world)
        self.rank = rank
        self.id = self.world.intersection_ids[self.rank]
        self.inter_obj = self.world.id2intersection[self.id]

        self.phase = Registry.mapping['model_mapping']['setting'].param['phase']
        self.one_hot = Registry.mapping['model_mapping']['setting'].param['one_hot']

        self.action_space = spaces.Discrete(len(self.inter_obj.phases))
        self._create_generators()
        # follow PettingZoo Env, use spaces.Box as observation_space
        if type(self.ob_generator) == list:
            if type(self.ob_generator[0]) == list:
                # homogenous sub-agents
                self.ob_length = sum([ob_g.ob_length for ob_g in self.ob_generator[0]])
            else:
                self.ob_length = sum([ob_g.ob_length for ob_g in self.ob_generator])

        else:
            self.ob_length = self.ob_generator.ob_length
            self.ob_generator = [self.ob_generator]

        if self.phase:
            if self.one_hot:
                self.ob_length += len(self.inter_obj.phases)
            else:
                self.ob_length += 1
        self.observation_space = spaces.Box(low=np.zeros(self.ob_length, dtype=np.float32),
                                            high=np.ones(self.ob_length, dtype=np.float32))
        
        assert all([hasattr(self, generator) for generator in ['ob_generator', 'phase_generator',\
            'reward_generator', 'queue', 'delay']]), 'missing generators'

    def _create_generators(self):
        self.ob_generator = LaneVehicleGenerator(self.world, self.inter_obj,
                                                 ["lane_count"], in_only=True, average=None)
        self.phase_generator = IntersectionPhaseGenerator(self.world, self.inter_obj,
                                                          ['phase'], targets=['cur_phase'], negative=False)
        self.reward_generator = LaneVehicleGenerator(self.world, self.inter_obj,
                                                     ["lane_waiting_count"], in_only=True, average="all",
                                                     negative=True)
        self.queue = LaneVehicleGenerator(self.world, self.inter_obj,
                                                     ["lane_waiting_count"], in_only=True, average="all",
                                                     negative=False)
        self.delay = LaneVehicleGenerator(self.world, self.inter_obj,
                                                     ["lane_delay"], in_only=True, average="all",
                                                     negative=False)

    def reset(self):
        '''
        reset
        Reset information, including ob_generator, phase_generator, queue, delay, etc.

        :param: None
        :return: None
        '''
        self._create_generators()

    def get_ob(self):
        '''
        get_ob
        Get observation from environment.

        :param: None
        :return: observation generated by ob_generator
        '''
        x_obs = np.array([ob_g.generate() for ob_g in self.ob_generator], dtype=np.float32).reshape(1,-1)
        return x_obs

    def get_phase(self):
        '''
        get_phase
        Get current phase of intersection(s) from environment.

        :param: None
        :return: current phase generated by phase_generator
        '''
        phase = [self.phase_generator.generate()]
        phase = np.array(phase, dtype=np.int8)
        return phase

    def get_reward(self):
        '''
        get_reward
        Get reward from environment.

        :param: None
        :return: reward generated by reward_generator
        '''
        rewards = []
        rewards.append(self.reward_generator.generate())
        rewards = np.squeeze(np.array(rewards))
        assert rewards.size == 1
        return rewards

    def get_action(self):
        '''
        get_action
        Generate action.

        :param: None
        :return: action generated by sample function
        '''
        return self.action_space.sample()
    
    def sample(self):
        '''
        sample
        Sample action randomly.

        :param: None
        :return: action generated randomly.
        '''
        return random.randint(0,self.action_space.n-1)

    def get_queue(self):
        '''
        get_queue
        Get queue length of intersection.

        :param: None
        :return: total queue length
        '''
        queue = []
        queue.append(self.queue.generate())
        # sum of lane nums
        queue = np.sum(np.squeeze(np.array(queue)))
        return queue

    def get_delay(self):
        '''
        get_delay
        Get delay of intersection.

        :param: None
        :return: total delay
        '''
        delay = []
        delay.append(self.delay.generate())
        delay = np.sum(np.squeeze(np.array(delay)))
        return delay

def remember(self, last_obs, last_phase, actions, actions_prob, rewards, obs, cur_phase, done, key):
    raise NotImplementedError