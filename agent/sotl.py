from . import BaseAgent
from common.registry import Registry
from generator import LaneVehicleGenerator, IntersectionPhaseGenerator, IntersectionVehicleGenerator
import numpy as np
import gym


@Registry.register_model('sotl')
class SOTLAgent(BaseAgent):
    '''
    SOTLAgent using Self-organizing Traffic Light(SOTL) Control method to control traffic light.
    '''
    def __init__(self, world, rank):
        super().__init__(world)
        self.world = world
        self.rank = rank
        # some threshold to deal with phase requests
        self.min_green_vehicle = Registry.mapping['model_mapping']['setting'].param['min_green_vehicle']
        self.max_red_vehicle = Registry.mapping['model_mapping']['setting'].param['max_red_vehicle']
        self.t_min = Registry.mapping['model_mapping']['setting'].param['t_min']
        # get generator for each SOTL
        inter_id = self.world.intersection_ids[self.rank]
        inter_obj = self.world.id2intersection[inter_id]
        self.model = None
        self.inter = inter_obj
        self.ob_generator = LaneVehicleGenerator(self.world, self.inter, ['lane_waiting_count'], in_only=True, average=None)
        self.phase_generator = IntersectionPhaseGenerator(world, self.inter, ["phase"],
                                                          targets=["cur_phase"], negative=False)
        self.reward_generator = LaneVehicleGenerator(self.world, self.inter, ["lane_waiting_count"],
                                                     in_only=True, average='all', negative=True)
        self.queue = LaneVehicleGenerator(self.world, self.inter,
                                                     ["lane_waiting_count"], in_only=True,
                                                     negative=False)
        self.delay = LaneVehicleGenerator(self.world, self.inter,
                                                     ["lane_delay"], in_only=True,
                                                     negative=False)
        self.action_space = gym.spaces.Discrete(len(self.inter.phases))


    def __repr__(self):
        return 'SOTL Agent has no Network model'

    def reset(self):
        '''
        reset
        Reset information, including ob_generator, phase_generator, queue, delay, etc.

        :param: None
        :return: None
        '''
        inter_id = self.world.intersection_ids[self.rank]
        inter_obj = self.world.id2intersection[inter_id]
        self.inter = inter_obj
        self.ob_generator = LaneVehicleGenerator(self.world, self.inter, ['lane_waiting_count'], in_only=True, average=None)
        self.phase_generator = IntersectionPhaseGenerator(self.world, self.inter, ["phase"],
                                                          targets=["cur_phase"], negative=False)
        self.reward_generator = LaneVehicleGenerator(self.world, self.inter, ["lane_waiting_count"],
                                                     in_only=True, average='all', negative=True)
        self.queue = LaneVehicleGenerator(self.world, self.inter,
                                                     ["lane_waiting_count"], in_only=True,
                                                     negative=False)
        self.delay = LaneVehicleGenerator(self.world, self.inter,
                                                     ["lane_delay"], in_only=True,
                                                     negative=False)

    def get_phase(self):
        '''
        get_phase
        Get current phase of intersection(s) from environment.

        :param: None
        :return phase: current phase generated by phase_generator
        '''
        phase = []
        phase.append(self.phase_generator.generate())
        # phase = np.concatenate(phase, dtype=np.int8)
        phase = (np.concatenate(phase)).astype(np.int8)
        return phase

    def get_ob(self):
        '''
        get_ob
        Get observation from environment.

        :param: None
        :return x_obs: observation generated by ob_generator
        '''
        x_obs = []
        x_obs.append(self.ob_generator.generate())
        x_obs = np.array(x_obs, dtype=np.float32)
        return x_obs

    def get_reward(self):
        '''
        get_reward
        Get reward from environment.

        :param: None
        :return rewards: rewards generated by reward_generator
        '''
        rewards = []
        rewards.append(self.reward_generator.generate())
        rewards = np.squeeze(np.array(rewards)) * 12
        return rewards

    def get_action(self, ob, phase, test=True):
        '''
        get_action
        Generate action.

        :param ob: observation, the shape is (1,12)
        :param phase: current phase, the shape is (1,)
        :param test: boolean, decide whether is test process
        :return action: action that has the highest score
        '''
        lane_waiting_count = self.world.get_info("lane_waiting_count")
        assert phase[-1] == self.inter.current_phase
        action = self.inter.current_phase
        # Note: we assume current_phase_time always greater than yellow_Phase_time
        if self.inter.current_phase_time >= self.t_min:
            num_green_vehicles = sum([lane_waiting_count[lane] for
                                        lane in self.inter.phase_available_startlanes[self.inter.current_phase]])
            num_red_vehicles = sum([lane_waiting_count[lane] for lane in self.inter.startlanes])
            num_red_vehicles -= num_green_vehicles

            if (num_green_vehicles <= self.min_green_vehicle and num_red_vehicles > self.max_red_vehicle) or ((num_green_vehicles == 0 and num_red_vehicles > 0)):
                action = (self.inter.current_phase+1) % len(self.inter.phases)

        return action

    def get_queue(self):
        '''
        get_queue
        Get queue length of intersection.

        :param: None
        :return: total queue length
        '''
        queue = []
        queue.append(self.queue.generate())
        queue = np.sum(np.squeeze(np.array(queue)))
        return queue

    def get_delay(self):
        '''
        get_delay
        Get delay of intersection.

        :param: None
        :return: total delay
        '''
        delay = []
        delay.append(self.delay.generate())
        delay = np.sum(np.squeeze(np.array(delay)))
        return delay
