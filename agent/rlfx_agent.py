from . import BaseAgent
from common.registry import Registry
import gym
from generator import LaneVehicleGenerator, IntersectionPhaseGenerator, IntersectionVehicleGenerator
import random
import numpy as np


@Registry.register_model('rlfx')
class RLFXAgent(BaseAgent):
    '''
    RLAgent Class is mainly used for creating a rl-based agent controlling both phase and duration
    Currently it only supports all agents with same max duration(duration unit * duration space) and unit duration(duration unit),
    later we will add in graph to predefine agent individually before creating world class.
    '''
    def __init__(self, world, rank):
        super().__init__(world)

        self.rank = rank
        self.id = self.world.intersection_ids[self.rank]
        self.inter_obj = self.world.id2intersection[self.id]

        self.action_space = gym.spaces.Discrete(len(self.inter_obj.phases))
        # duration action space, decided by predefined value stored in dictionary

        self.duration_space = gym.spaces.Discrete(Registry.mapping['model_mapping']['setting'].param['duration_space'])
        self.duration_unit = Registry.mapping['model_mapping']['setting'].param['duration_unit']
        self.duration_min = Registry.mapping['model_mapping']['setting'].param['duration_min']
        try: 
            tmp_duration_spaces = Registry.mapping['model_mapping']['setting'].param['duration_spaces']
            tmp_duration_spaces = gym.spaces.Discrete(tmp_duration_spaces[self.rank])
            self.duration_space = tmp_duration_spaces
        except:
            pass

        try: 
            tmp_duration_units = Registry.mapping['model_mapping']['setting'].param['duration_units']
            tmp_duration_unit = tmp_duration_units[self.rank]
            self.duration_unit = tmp_duration_unit
        except:
            pass
        try: 
            tmp_duration_mins = Registry.mapping['model_mapping']['setting'].param['duration_mins']
            tmp_duration_min = tmp_duration_mins[self.rank]
            self.duration_min = tmp_duration_min
        except:
            pass
        self.action_interval = Registry.mapping['trainer_mapping']['setting'].param['action_interval']


        self.ob_generator = LaneVehicleGenerator(self.world, self.inter_obj,
                                                 ["lane_count"], in_only=True, average=None)
        self.phase_generator = IntersectionPhaseGenerator(self.world, self.inter_obj,
                                                          ['phase'], targets=['cur_phase'], negative=False)
        self.reward_generator = LaneVehicleGenerator(self.world, self.inter_obj,
                                                     ["lane_waiting_count"], in_only=True, average="all",
                                                     negative=True)
        self.queue = LaneVehicleGenerator(self.world, self.inter_obj,
                                                     ["lane_waiting_count"], in_only=True,
                                                     negative=False)
        self.delay = LaneVehicleGenerator(self.world, self.inter_obj,
                                                     ["lane_delay"], in_only=True, average="all",
                                                     negative=False)
        self.duration_residual = 0
        self.duration_cur = 0


    def reset(self):
        '''
        reset
        Reset information, including ob_generator, phase_generator, queue, delay, etc.

        :param: None
        :return: None
        '''
        self.inter_obj = self.world.id2intersection[self.id]

        self.ob_generator = LaneVehicleGenerator(self.world, self.inter_obj, ['lane_count'], in_only=True, average=None)
        self.phase_generator = IntersectionPhaseGenerator(self.world, self.inter_obj, ["phase"],
                                                          targets=["cur_phase"], negative=False)
        self.reward_generator = LaneVehicleGenerator(self.world, self.inter_obj, ["lane_waiting_count"],
                                                     in_only=True, average='all', negative=True)
        self.queue = LaneVehicleGenerator(self.world, self.inter_obj,
                                                     ["lane_waiting_count"], in_only=True,
                                                     negative=False)
        self.delay = LaneVehicleGenerator(self.world, self.inter_obj,
                                                     ["lane_delay"], in_only=True, average="all",
                                                     negative=False)
        self.duration_residual = 0
        self.duration_cur = 0


    def get_ob(self):
        '''
        get_ob
        Get observation from environment.

        :param: None
        :return: observation generated by ob_generator
        '''
        return self.ob_generator.generate()

    def get_phase(self):
        '''
        get_phase
        Get current phase of intersection(s) from environment.

        :param: None
        :return: current phase generated by phase_generator
        '''
        return self.phase_generator.generate()

    def get_reward(self):
        '''
        get_reward
        Get reward from environment.

        :param: None
        :return: reward generated by reward_generator
        '''
        reward = self.reward_generator.generate()
        assert len(reward) == 1
        return reward[0]

    def get_action(self, state, phase, test=True):
        '''
        get_action
        Generate action.

        :param: None
        :return: action generated by sample function
        '''
        return self.sample()
    
    def sample(self):
        '''
        sample
        Sample action randomly.

        :param: None
        :return: action generated randomly.
        '''
        if self.duration_residual != 0:
            self.duration_residual -= self.action_interval
            return self.get_phase()
        else:
            # this is duration sampling
            tmp_duration = self.duration_space.sample()
            self.duration_cur = tmp_duration * self.duration_unit + self.duration_min
            self.duration_residual = self.duration_cur - self.action_interval
            # this is phase sampling
            return self.action_space.sample()

    def get_queue(self):
        '''
        get_queue
        Get queue length of intersection.

        :param: None
        :return: total queue length
        '''
        queue = []
        queue.append(self.queue.generate())
        # sum of lane nums
        queue = np.sum(np.squeeze(np.array(queue)))
        return queue

    def get_delay(self):
        '''
        get_delay
        Get delay of intersection.

        :param: None
        :return: total delay
        '''
        delay = []
        delay.append(self.delay.generate())
        delay = np.sum(np.squeeze(np.array(delay)))
        return delay

    """
    def choose(self, **kwargs):
        raise NotImplementedError
    """
    def get_duration(self):
        return self.duration_cur
